## Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Харьков П.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Решать логические задачи можно разными способами, к примеру, строить таблицы истинности или, конечно, же просто рассуждением. Но так же логические задачи можно решать с помощью логики предикатов, то есть такую задачу можно решить с помощью декларативного программирования. А Prolog и является декларативным языком! Так как в языке Prolog мы описываем свойства задачи, а не ее решение, то решение логической задачи превращается в простое описание свойств, данных в ней. Он перебирает все возможные условия для каждого свойства, и если какие-то данные не удовлетворяют условиям, то отбрасывает решения с этими данными. В результате остаются лишь те решения, данные которых удовлетворяют всем условиям.

## Задание

В Н-ской части служили 5 офицеров: генерал, полковник, майор, капитан и лейтенант. Один из них  сапер, другой  пехотинец, третий  танкист, четвертый  связист, а пятый  артиллерист. У каждого из них есть сестра. И каждый из них женат на сестре своего однополчанина. Вот что еще известно об этих офицерах. Связист  не самый старший по званию. Капитан никогда не служил в Горьком. Оба родственника пехотинца и оба родственника танкиста служили раньше в Ленинграде. Ни один родственник генерала в Ленинграде не был. Танкист служил в Киеве вместе с обоими своими родственниками, а лейтенант там не служил. Полковник служил в Свердловске вместе со своими родственниками. Танкист не служил в Свердловске. Там служил только один из его родственников. Генерал служил с обоими своими родственниками в Горьком, а в Свердловске он не бывал. Артиллерист не служил ни в Горьком, ни в Киеве. Определите, кто из офицеров какое звание имеет?

## Принцип решения

Перед тем, как решать задачу, необходимо определить несколько предикатов, которые мы будем использовать для решения задачи.

Реализация предикатов для проверки принадлежит элемент списку или нет:
```prolog
member(Elem, [Elem|_]).
member(Elem, [_|Tail]) :- member(Elem, Tail).

not_member(_, []).
not_member(Elem, [Head|Tail]) :- Elem \= Head, not_member(Elem, Tail).
```

Предикат принадлежности только одного элемента списку:
```prolog
onerelative(Ans, Y1, Y2) :- not_member(Y2, Ans), !, member(Y1, Ans).
onerelative(Ans, _, Y2) :- member(Y2, Ans).
```

Теперь перейдем к предикату `solve`. Для решения задачи я реализовал список `Ans`, содержащий в себе информацию о каждом офицере в виде списка: `[Профессия, звание, [Горький, Ленинград, Киев, Свердловск], профессия мужа сестры, профессия брата жены]`. В списке городов элемент я буду заполнять `true` термой, если офицер там служил и `false` термой, если нет. Так как каждый офицер женат на сестре другого офицера, то я сделал в списке элемент, который содержит профессию мужа сестры и элемент, которой содержит профессию брата жены. 

Список `Ans`:
```prolog
Ans = [  [сапер, SaperRank, [_, _, _, _], SisterSaper, WifeSaper],
         [пехотинец, PehotRank, [_, _, _, _], SisterPehot, WifePehot], 
         [танкист, TankRank, [_, _, _, _], SisterTank, WifeTank], 
         [связист, SvyzRank, [_, _, _, _], SisterSvyz, WifeSvyz], 
         [артиллерист, ArtylRank, [_, _, _, _], SisterArtyl, WifeArtyl]    ]
```

Затем я получаю все перестановки званий:
```prolog
permutation([генерал, полковник, майор, капитан, лейтенант], 
            [SaperRank, PehotRank, TankRank, SvyzRank, ArtylRank])
```

Далее описаны все свойства, которые даны в условии задачи:
```prolog
% Связист не самый старший по званию.
SvyzRank \= генерал,

% Капитан никогда не служил в Горьком.
member([_, капитан, [false, _, _, _], _, _], Ans),

% Оба родственника пехотинца служили раньше в Ленинграде
member([SisterPehot, _, [_, true, _, _], _, пехотинец], Ans),
member([WifePehot, _, [_, true, _, _], пехотинец, _], Ans),

% Оба родственника танкиста служили раньше в Ленинграде.  
member([SisterTank, _, [_, true, _, _], _, танкист], Ans),
member([WifeTank, _, [_, true, _, _], танкист, _], Ans),

% Ни один родственник генерала в Ленинграде не был.
member([General, генерал, _, SisterGeneral, WifeGeneral], Ans), 
member([SisterGeneral, _, [_, false, _, _], _, General], Ans),
member([WifeGeneral, _, [_, false, _, _], General, _], Ans),

% Танкист служил в Киеве
member([танкист, _, [_, _, true, _], _, _], Ans), 

% Оба родственника танкиста служили в Киеве
member([SisterTank, _, [_, _, true, _], _, танкист], Ans),
member([WifeTank, _, [_, _, true, _], танкист, _], Ans),

% Лейтенант не служил в Киеве.
member([_, лейтенант, [_, _, false, _], _, _], Ans),

% Полковник служил в Свердловске 
member([_, полковник, [_, _, _, true], _, _], Ans),

% Оба родственника полковника служили в Свердловске.
member([Polkov, полковник, _, SisterPolkov, WifePolkov], Ans), 
member([SisterPolkov, _, [_, _, _, true], _, Polkov], Ans),
member([WifePolkov, _, [_, _, _, true], Polkov, _], Ans), 

% Танкист не служил в Свердловске. 
member([танкист, _, [_, _, _, false], _, _], Ans), 

% Только один из родственников танкиста служил в Свердловске.
onerelative(Ans, [SisterTank, _, [_, _, _, true], _, танкист], 
                [WifeTank, _, [_, _, _, true], танкист, _]), 

% Генерал служил в Горьком
member([_, генерал, [true, _, _, _], _, _], Ans),  

% Оба родственника генерала служили в Горьком
member([SisterGeneral, _, [true, _, _, _], _, General], Ans),
member([WifeGeneral, _, [true, _, _, _], General, _], Ans),

% Генерал в Свердловске не бывал.
member([_, генерал, [_, _, _, false], _, _], Ans),

% Артиллерист не служил ни в Горьком, ни в Киеве.
member([артиллерист, _, [false, _, false, _], _, _], Ans),
```

После описания всех свойств, которые даны в условии, я проверяю профессии родственников не равны:
```prolog
SisterSaper \= WifeSaper,
SisterPehot \= WifePehot,
SisterTank \= WifeTank,
SisterSvyz \= WifeSvyz,
SisterArtyl \= WifeArtyl,
```

И вывожу результат:
```prolog
write(Ans), nl,
write("Сапер: "), write(SaperRank), nl,
write("Пехотинец: "), write(PehotRank), nl,
write("Танкист: "), write(TankRank), nl,
write("Связист: "), write(SvyzRank), nl,
write("Артиллерист: "), write(ArtylRank), nl.
```

Пример работы программы:
```prolog
?- solve().
[[сапер,генерал,[true,true,true,false],пехотинец,танкист],
[пехотинец,лейтенант,[true,false,false,true],артиллерист,сапер],
[танкист,майор,[true,false,true,false],сапер,связист],
[связист,капитан,[false,true,true,true],танкист,артиллерист],
[артиллерист,полковник,[false,true,false,true],связист,пехотинец]]
Сапер: генерал
Пехотинец: лейтенант
Танкист: майор
Связист: капитан
Артиллерист: полковник
true ;
false.
```

Сложность алгоритма - O(n!), где n - количество офицеров. Это значение равно количеству всех возможных перестановок званий. В остальных предикатах сложность - O(n), так как лишь проходимся по списку длины n.

 Решение безопасное, так как у всех рекурсий, которые используются, есть "терминатор".

 Непротиворечивость решения можно доказать, тем, что программа вывела решение и решение было одно. Если бы хотя бы один предикат(в данном случае описывающий свойство по условию задачи) не выполнился, то в дереве решений это решение было бы неверным. Так как решение было получено, то все условия были выполнены.

## Выводы

После выполнения лабораторной работы я понял, что решать задачи на декларативном языке программирования гораздо проще, чем на императивном, из-за автоматического подбора перестановки данных, удовлетворяющей условию. Ведь для решения задач необходимо описать лишь условие задачи, а не то, как работать со списком и т.п. Также я научился пользоваться предикатом permutation - в первом варианте моей работы, я генерировал все возможные перестановки и затем оставлял только те перестановки, в которых все термы уникальные. Раньше из-за этого сложность моего алгоритма была O(n^n), а не O(n!). 

