# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Харьков П.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Мне кажется, что выполняя задания курсового проекта я научусь очень многому. Особенно важно, что этот курсовой проект покрывает минимальный набор знаний, которые я буду получать в течение семестра.

Первые два задания мне не кажутся сложными, так как создание родословного дерева и его парсер на языке Питон я могу сделать сразу, так как я знаком с языком Питон. Остальные три задания уже вызывают вопросы.
Для того, чтобы выполнить третье задание мне будет необходимо изучить основы языка Пролог, такие, как синтаксис и логика языка. Так как Пролог не императивный язык программирования, в начале его понимание будет даваться не особо легко. После того, как я изучу основы, мне необходимо будет изучить идеи и способы реализации поиска в Прологе. Скорее всего, как и везде, можно будет реализовать поиск в глубину или ширину. Для пятого же задания мне необходимо будет изучить грамматику в Прологе, это одно из основополагающее знание, так как без него будет трудно обработать строку, либо её сгенерировать.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска .... 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Я решил выбрать родословное дерево Дома Виндзор, но, к сожалению, не нашел в интернете GEDCOM файла с этим деревом. Все дерево я сам внес на сайте [MyHeritage.com](https://www.myheritage.com/).
В моем дереве внесены 47 индивидуумов:.

![Родословное дерево](https://i.ibb.co/k48cZ59/Tree.jpg)

Как можно увидеть, в нём есть 6 поколений, так что вариантов родства в нём очень много.


## Конвертация родословного дерева

Для конвертации родословного дерева я использовал язык программирования Python. Также я нашел очень удобную библиотеку для того, чтобы парсить GEDCOM файл. Сначала необходимо импортировать её:
```python
from gedcom.parser import Parser
from gedcom.element.individual import IndividualElement
```

Получение имени человека я реализовал так: сначала нахожу его фамилию и имя, а затем объединяю их, добавляя в начало и в конец кавычки, так как имя начинается с большой буквы.
```python
def get_name(person):
    (first, last) = person.get_name()
    if(last != ""):
        return "\'" + first + " " + last + "\'"
    return "\'" + first + "\'"
```

Добавление человека в список `males` или `females` происходит так: получаю гендер человека и добавляю его в определенный список.
```python
def add_gender(person, males, females):
    gender = person.get_gender()
    if(gender == "M"):
        males.append("male(" + get_name(person) + ").")
    elif(gender == "F"):    
        females.append("female(" + get_name(person) + ").")
```

Для каждого человека из родословного дерева я добавляю его в список `males` или `females` взависимости от его пола. А затем если этот человек чей-то ребёнок, то я добавляю его родителей в список `сhilds`.
```python
for person in root_child_elements:
    if isinstance(person, IndividualElement):
        add_gender(person, males, females)    
        if(person.is_child()):
            for parent in gedcom_parser.get_parents(person, "ALL"):
                childs.append("child(" + get_name(person) + ", " + get_name(parent) + ").")
```

После обработки всех людей из списка я сохроняю их в файл.

## Предикат поиска родственника

По заданию мне было необходимо реализовать предикат для поиска/проверки троюродного брата или сестры.

Для начала реализуем поиск обычных братьев и сестер. Я ограничиваю родителя отцом, так как со стороны матери все результаты аналогичны:
```prolog
sibling(X, Y) :- child(X, Z), child(Y, Z), male(Z), Y \= X.
```

Так как двоюродные братья и сестры - это дети братьев или сестёр родителей, то предикат выклядит так:
```prolog
cousin(X, Y) :- child(X, Z), sibling(Z, V), child(Y, V). 
```

И вот мы подошли к нашему заданию. Так как троюродные братья и сестры - это дети двоюродных братьев или сестёр родителей, то предикат реализован так:
```prolog
secondcousin(X, Y) :- child(X, Z), cousin(Z, V), child(Y, V).
```

Результаты работы программы:
```prolog
?- cousin('Prince George', X).
X = 'Archie' ;
?- secondcousin('Prince George', X).
X = 'Savannah Phillips' ;
X = 'Isla Phillips' ;
X = 'Mia Tindall' ;
X = 'Lena Tindall' ;
?- secondcousin('Prince George', 'Archie').
false.
```

## Определение степени родства

Для начала необходимо определить минимум отношений между двумя индивидуумами. Мы определим брата, сестру, сына, дочь, отца и мать. С помощью этих отношений можно определить любые отношения между двумя людьми.
```prolog
tie('brother', X, Y) :- sibling(X, Y), male(Y).
tie('sister', X, Y) :- sibling(X, Y), female(Y).
tie('son', X, Y) :- child(Y, X), male(Y).
tie('daughter', X, Y) :- child(Y, X), female(Y).
tie('father', X, Y) :- child(X, Y), male(Y).
tie('mother', X, Y) :- child(X, Y), female(Y).
```

Затем мне необходимо определить, какие шаги может выполнять мой поиск. Мне показалось достаточным реализовать шаг к родителям, шаг к детям и шаг к братьям и сёстрам:
```prolog
next(X, Z) :- child(X, Z).
next(X, Z) :- child(Z, X).
next(X, Z) :- sibling(X, Z).
```

Так как я решил реализовать поиск в глубину с итерационным заглублением, то необходимо реализовать генератор арифметической прогрессии, прибавляющий на каждом шаге единицу. Ограничение в 12 элементов на пути я сделал, так как у меня только 6 поколений, так что все связи найдутся за 12 итераций.:
```prolog
plus_one(1).
plus_one(M):- plus_one(N), (N < 12 -> M is N+1; !, fail).
```

Поиск в глубину реализован так: если нашлась связь между людьми, то мы, выходя из рекурсии, получаем список отношений между людьми, которые были на пути. Если же связь не нашлась, то мы делаем следующий шаг, и рекурсивно ищем относительно нового человека. Поиск выводит, только когда N = 1, чтобы не было повторений решений при повторном проходе поиском в глубину.
```prolog
search(Path, X, Y, N) :- N = 1, tie(A, X, Y), Path = [A].
search(Path, X, Y, N) :- N > 1, next(X, Z), N1 is N-1, search(Res, Z, Y, N1), tie(B, X, Z), append([B], Res, Path).
```

После получения списка связей на пути, нам необходимо распарсить этот список в желаемом нами формате:
```prolog
:- op(200, xfy, --->).
parse(X--->Z, [X|T]) :- parse(Z, T).
parse(X, [X]).
```

И вот мы подошли к поиску. Возможны 2 случая:
1. Если необходимо найти путь, то мы выполняем поиск с итерационным углублением и затем парсим результаты. 
2. Если путь нам дан, то мы парсим его в список, находим его длину и ищем элементы, у которых только эта длина пути.
```prolog
relative(Res, X, Y) :- var(Res), plus_one(N), N < 12, search(L, X, Y, N), Y \= X, parse(Res, L).
relative(Res, X, Y) :- nonvar(Res), parse(Res, L), length(L, N), search(L, X, Y, N), Y \= X.
```

Результаты работы:
```prolog
?- relative(X, 'Prince George', 'Prince William, Duke of Cambridge').
X = father ;
X = sister--->father ;
X = brother--->father ;
...
?- relative(X, 'Prince George', Y).                                   
X = brother,
Y = 'Prince Louis' ;
X = sister,
Y = 'Princess Charlotte' ;
X = father,
Y = 'Prince William, Duke of Cambridge' ;
...
?- relative(father->brother->son, 'Prince George', X).
X = 'Archie' ;
```

## Естественно-языковый интерфейс

Я решил реализовать возможность ввода 4 различных запросов, на примере таких: 
1. Who is brother to Petya ?
2. What relations between Petya and Vasya ?
3. Is Petya brother to Vasya ?
4. How many brother Vasya has ?

При запросе я просто делаю парсинг, затем ищу ответ по типу вопроса и вывожу результат. Парсинг происходит так: разбиваю предложение на 3 части. Первая часть разбирает начало, и в нем я нахожу тип вопроса. Вторая часть разбивает предложение так, как необходимо для этого типа вопроса и находит необходимые аргументы. Третья часть для того, чтобы последнее слово было вопросительным знаком.
```prolog
ask(L, Res) :- parseask(Type, Tie, X, Y, L, []), ans(Type, Tie, X, Y, Res).

parseask(Type, Tie, X, Y) --> quest(Type), body(Type, Tie, X, Y), quessign.
quessign --> [?].
```

Если начало строки состоит из этих элементов, то мы определяем тип вопроса для того, чтобы понять, какой выдать ответ. Реализация такая:
```prolog
quest(who) --> [who], [is].
quest(relation)  --> [what], word, ['between'].
quest(truefalse) --> [is].
quest(howmany)   --> [how], [many].
word --> [X], {member(X, [relationships, relations])}.
```

Вторая часть основная. Сначала я обрабатываю строку в определённом для вопроса формате, а затем ищу необходимый результат. Реализация:
```prolog
body(who, Tie, X, _)      --> name(Tie), [to], name(X).
body(relation, _, X, Y) --> name(X), [and], name(Y).
body(truefalse, Tie, X, Y)--> name(X), name(Tie), [to], name(Y).
body(howmany, Tie, X, _)  --> name(Tie), name(X), [has].
```

Предикат `name` необходим, так как имя могут ввести и с артиклем, и без него, так что имя разбираю я отдельно:
```prolog
name(X) --> [Y], [X], {member(Y, [the, a])}, !.
name(X) --> [X].
```

Реализация поиска результата по полученным данным:
```prolog
ans(who, Tie, X, _, Res) :- relative(Tie, X, Res).
ans(relation, _, X, Y, Res) :- relative(Res, Y, X).
ans(truefalse, Tie, X, Y, Res) :- (relative(Tie, Y, X) -> Res = yes; Res = no).
ans(who, Tie, X, _, Res) :- findall(Y, relative(Tie, X, Y), L), length(L, Res).
```

Результат работы программы:
```prolog
?- ask([who, is, brother, to, 'Prince George', ?], X).
X = 'Prince Louis' ;
?- ask([what, relations, between, 'Prince George', and, 'Archie', ?], X).
X = father--->brother--->son ;
X = father--->father--->son--->son ;
...
?- ask([how, many, father--->brother, 'Prince William, Duke of Cambridge', has, ?], X). 
X = 2.
?- ask([is, 'Prince Louis', sister, to, 'Prince George', ?], X). 
X = no.
?- ask(X, Y).
X = [who, is, brother, to, the, 'Prince William, Duke of Cambridge', ?],
Y = 'Prince Henry, Duke of Sussex' ;
X = [who, is, brother, to, the, 'Prince George', ?],
Y = 'Prince Louis' ;
...
```

## Выводы

Выполнив курсовой проект, я научился очень многому. Я изучил основы синтаксиса и логики в языке Пролог, изучил варианты поиска необходимых состояний, а также основы грамматики в Прологе. Мне очень понравилось то, что мы можем реализовать один предикат, но использовать разными способами для получения необходимого результата: такого в императивных языках не получится реализовать. Также мне понравилось реализовывать парсинг строк с помощью DCG грамматики - она значительно упрощает парсинг, так как нет необходимости разбивать строку самостоятельно на подстроки. Особенно удобно то, что можно использовать фигурные скобки, для того, чтобы использовать какой-либо предикат, а также то, что можно использовать структуру (predicate -> true ; false), для того, чтобы удобно строить if-else выражения. Мне кажется, что если мне надо будет быстро решить логическую задачу, которую можно решить перебором, то я сразу же обращусь к Прологу. Это самый оптимальный из возможных языков для решения таких задач.
