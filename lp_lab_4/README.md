## Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Харьков П.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Пролог является удобным языком программирования для обработки естественных и искусственных языков, так как в нем необходимо задать лишь правила этого языка, ведь это декларативный язык. То есть, если у нас есть некое предложение на языке, правила построения этого предложения, то нам лишь необходимо описать эти правила и составить словарь возможных слов; нам не нужно думать, как в Прологе будут сравниваться слова, и он сам построит это предложение в виде дерева. Для работы с грамматикой был придуман DCG, такая оболочка над Прологом, благодаря которой упрощается описание правил в грамматике, но она всегда транслируется в обычный код Пролога. 

## Задание

Реализовать преобразватель активных и пассивных форм типа:
['Саша', 'и', 'Лена', 'любят', 'шоколад'] и 
['шоколад', 'любим', 'Сашей', 'и', 'Петей']
в глубинные структуры типа и сравнить полученные глубинные структуры.

Запрос:
```prolog
compare(['Саша', 'и', 'Лена', 'любят', 'шоколад'], 
['шоколад', 'любим', 'Сашей', 'и', 'Леной'], Ph1, Ph2, Y).
```
Результат:
```prolog
Ph1=likes([agent('Саша'), agent('Лена')], object('шоколад')), 
Ph2=likes([agent('Саша'), agent('Лена')], object('шоколад')), Y=yes.
```

## Принцип решения

Для начала необходимо составить словари глаголов и существительных. Словарь глаголов представлен как 'глагол в начальной форме:залог:список глаголов в этом залоге':
```prolog
verbs(L) :- L = [
'любить':zalog('актив'):['люблю', 'любишь', 'любит', 'любим', 'любите', 'любят'],
'любить':zalog('пассив'):['любим', 'любима', 'любимо', 'любимы']
].
```

Словарь существительных представлен как 'существительное в начальной форме:падеж:список существительных в этом падеже':
```prolog
nouns(L):- L=[
'Лена':pad('именит'):['Лена'],
'Лена':pad('винит'):['Лену'],
'Лена':pad('творит'):['Леной'],

'Саша':pad('именит'):['Саша'],
'Саша':pad('винит'):['Сашу'],
'Саша':pad('творит'):['Сашей'],

'Петя':pad('именит'):['Петя'],
'Петя':pad('винит'):['Петю'],
'Петя':pad('творит'):['Петей'],

'шоколад':pad('именит'):['шоколад'],
'шоколад':pad('винит'):['шоколад'],
'шоколад':pad('творит'):['шоколадом']
].
```

Также необходимо составить список союзов, в данном случае соединительных:
```prolog
unions(L) :- L = ['и', 'да'].
``` 

Для удобного разбора каждого слова в словаре я определил оператор двоеточия:
```prolog
:- op(200, xfy, ':').
```

По условию задания небходимо сравнить два предложение и вывести, одинаковое ли у них значение. Для этого я реализовал предикат `compare`:
```prolog
compare(List1, List2, Ph1, Ph2, Res):-
    an_phrase(Ph1, List1),
    an_phrase(Ph2, List2),
    Ph1 = Ph2, !,
    Res = yes.

compare(List1, List2, Ph1, Ph2, Res):-
    an_phrase(Ph1, List1),
    an_phrase(Ph2, List2), !,
    Res = no.
```

Для каждого слова проверяется, есть ли оно в словаре и в правильной ли оно форме. Предложение должно быть в виде 'существительное в именительном падеже, союз, существительное в именительном падеже, глагол в активном залоге, существительное в винительном падеже' или  'существительное в именительном падеже, глагол в пассивном залоге, существительное в творительном падеже, союз, существительное в творительном падеже'. Реализация предиката:
```prolog
an_phrase(Res, [A,B,C,D,E]):-
    an_noun(Ag1, pad('именит'), A),
    an_union(B),
    an_noun(Ag2, pad('именит'), C),
    an_verb(Verb, zalog('актив'), D),
    an_noun(Obj, pad('винит'), E),
    Res =..[Verb, [agent(Ag1), agent(Ag2)], object(Obj)].

an_phrase(Res, [A,B,C,D,E]):-
    an_noun(Obj, pad('именит'), A),
    an_verb(Verb, zalog('пассив'), B),
    an_noun(Ag1, pad('творит'), C),
    an_union(D),
    an_noun(Ag2, pad('творит'), E),
    Res =..[Verb, [agent(Ag1), agent(Ag2)], object(Obj)].
```

Поиск по словарю происходит перебором каждого слова в словаре и нахождения совпадающего слова в списке форм слова:
```prolog
an_noun(StartForm, Form, X):- nouns(L), find(X, StartForm, Form, L).
an_verb(StartForm, Form, X):- verbs(L), find(X, StartForm, Form, L).
an_union(X) :- unions(L), member(X, L).

find(X, StartForm, Form, L) :- member(Word, L), condition(X, StartForm, Form, Word).
condition(X, StartForm, Form, StartForm:Form:LForms) :- member(X, LForms).
```

## Результаты

Результаты работы программы:
```prolog
?- compare(['Саша', 'и', 'Лена', 'любят', 'шоколад'], ['шоколад', 'любим', 'Сашей', 'и', 'Леной'], Ph1, Ph2, Y).
Ph1 = Ph2, Ph2 = любить([agent('Саша'), agent('Лена')], object(шоколад)),
Y = yes.

?- compare(['Саша', 'и', 'Лена', 'любят', 'шоколад'], ['шоколад', 'любим', 'Сашей', 'и', 'Петей'], Ph1, Ph2, Y).
Ph1 = любить([agent('Саша'), agent('Лена')], object(шоколад)),
Ph2 = любить([agent('Саша'), agent('Петя')], object(шоколад)),
Y = no.

?- compare(['Саша', 'и', 'Лена', 'любят', 'шоколадки'], ['шоколад', 'любим', 'Сашей', 'и', 'Петей'], Ph1, Ph2, Y).
false.
```

## Выводы

Эта лабораторная работа научила меня работать с грамматикой русского языка в Прологе. Это полезное умение, так как в будущем это поможет мне анализировавать тексты. К примеру, разбирать стилистики текстов, вложенность предложений. Пролог оказался очень удобным, так как мне необходимо было необходимо лишь задать словари и правило построения предложения. Я заметил, что использование DCG значительно упрощает описание грамматики и построение деревьев, но в данной лабораторной работе мне все же было удобнее использовать обычный синтаксис Пролога. А также, моя программа часто зацикливалась, когда я неправильно расстанавливал правила в DCG командах.


