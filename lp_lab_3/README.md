## Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Харьков П.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Язык Prolog является удобным языком для поиска решений в пространстве состояний, так как с помощью него легко искать и перебирать все возможные варианты состояний. Для поиска необходимого состояния существует много алгоритмов, таких как: поиск А, IDA, жадный алгоритм поиска. Но мы рассмотрим только три других видов поиска: поиск в глубину, поиск в ширину и поиск в глубину с итерационным углублением.

Поиск в глубину - метод обхода графа, который состоит в том, чтобы идти "вглубь" графа, насколько это возможно.

Поиск в ширину - метод обхода графа, в котором сначала мы рассматриваем все узлы на одном уровне, и лишь после опускаемся на уровень ниже.

Поиск в глубину с итерационным заглублением - метод обхода графа, в котором мы постепенно увеличиваем возможную длину пути в поиске в глубину.

## Задание

Вдоль доски расположены 7 лунок, в которых лежат 3 черных и белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в лунку, находящуюся непосредственно за ближайшим шаром.

## Принцип решения

Мои обозначения: `b` - черные шары, `w` - белые шары.
Для начала необходимо описать предикат движения шаров. В этом предикате происходит разбиение списка для того, чтобы пустая лунка была в центре. К сожалению, я не нашел способа описать все возможные шаги более коротким способом. В случае краевых состояний, я заполняю `x` все лунки, которые не должны существовать. Его реализация:
```prolog
%move(        Input                   After Step        )
move([o, B, C, D, E, F, G], [A1, B1, C1, D,  E,  F,  G ]) :- step([x, x, o, B, C], [x,  x,  A1, B1, C1]).
move([A, o, C, D, E, F, G], [A1, B1, C1, D1, E,  F,  G ]) :- step([x, A, o, C, D], [x,  A1, B1, C1, D1]).
move([A, B, o, D, E, F, G], [A1, B1, C1, D1, E1, F,  G ]) :- step([A, B, o, D, E], [A1, B1, C1, D1, E1]).
move([A, B, C, o, E, F, G], [A,  B1, C1, D1, E1, F1, G ]) :- step([B, C, o, E, F], [B1, C1, D1, E1, F1]).
move([A, B, C, D, o, F, G], [A,  B,  C1, D1, E1, F1, G1]) :- step([C, D, o, F, G], [C1, D1, E1, F1, G1]).
move([A, B, C, D, E, o, G], [A,  B,  C,  D1, E1, F1, G1]) :- step([D, E, o, G, x], [D1, E1, F1, G1, x ]).
move([A, B, C, D, E, F, o], [A,  B,  C,  D,  E1, F1, G1]) :- step([E, F, o, x, x], [E1, F1, G1, x,  x ]).
```

Реализация предиката `step` для белых шаров:
```prolog
% step(  Input,          After Step  )
step([A, w, o, D, E], [A, o, w, D, E]).
step([w, B, o, D, E], [o, B, w, D, E]).
step([A, B, o, w, E], [A, B, w, o, E]).
step([A, B, o, D, w], [A, B, w, D, o]).
```
Для черных шаров реализация такая же. Мне необходимо описывать явно, что на определенном месте находится белый или черный, так как существуют краевые случаи, когда лунка находится около края. 

Затем необходимо описать предикат для шага, который переводит систему в следующее состояние: 
```prolog
next([X|T], [Y, X|T]):- move(X, Y), not(member(Y, [X|T])).
```

Поиск в глубину:
```prolog
depth([L|T], [L|T]) :- L = [b, b, b, o, w, w, w], !.
depth(L, Res) :- next(L, NewL), depth(NewL, Res). 

dep():- L = [w, w, w, o, b, b, b], depth([L], Path), write(Path), nl.
```
Сначала проверяется, равен первый элемент списка конечному. Если равен, то путь получен. Если нет, то делается следующий шаг и рекурсивно ищем в глубину по новому состоянию.

Поиск в ширину:
```prolog
width([[L|T]|_], [L|T]) :- L = [b, b, b, o, w, w, w].
width([Elem|Top], ResPath):- findall(X, next(Elem, X), Bottom), append(Top, Bottom, AllL), !, width(AllL, ResPath).
width([_|T], ResPath):- width(T, ResPath).

wid():- L = [w, w, w, o, b, b, b], width([[L]], Res), write(Res), nl.
```
Сначала проверяется, равен первый элемент списка конечному: если равен, то путь получен. Затем для первого элемента из списков путей мы ищем все возможные варианты шагов и добавляем их в конец списка путей. Если хотя бы один возможный шаг был найден, то рекурсивно вызываем поиск в ширину для нового списка путей. Если же не было найдено ни одного возможного шага, то этот элемент удаляется и мы идем с помощью поиска в ширину по оставшимся элементов списка путей.

Для того, чтобы реализовать поиск в глубину с итерационным углублением для начала необходимо написать предикат, генерирующий бесконечную последовать возрастающих чисел, которые будут ограничивать длину пути поиска.
```prolog
plus_one(1).
plus_one(M):- plus_one(N), M is N + 1.
```

Реализация предиката поиска в глубину с ограниченим по длине пути:
```prolog
depth([L|T], [L|T], _) :- L = [b, b, b, o, w, w, w].
depth(L, Res, N) :- N > 0, next(L, NewL), N1 is N-1, depth(NewL, Res, N1).
```
Мы просто идем поиском в глубину, пока длина пути не больше `N`.

А для того, чтобы выполнить поиск в глубину с итерационным заглублением, необходимо вызвать предикат, который бесконечно прибавляет единицу к ограничению по поиску в глубину:
```prolog
id_find(L, Res):- plus_one(N), depth([L], Res, N).

idfdep():- L = [w, w, w, o, b, b, b], id_find(L, Path), write(Path), nl.
```

## Результаты

| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-----------------|--------------------------------|----------------|
| В глубину       |               66               |       0.5 с    |
| В ширину        |               16               |      52 с      |
| ID              |               16               |       1 c      |

Результат работы поиска в ширину:
```prolog
?- wid().
[[b,b,b,o,w,w,w],[b,b,b,w,o,w,w],[b,b,o,w,b,w,w],[b,o,b,w,b,w,w],[b,w,b,o,b,w,w],[b,w,b,w,b,o,w],[b,w,b,w,b,w,o],[b,w,b,w,o,w,b],[b,w,o,w,b,w,b],[o,w,b,w,b,w,b],[w,o,b,w,b,w,b],[w,w,b,o,b,w,b],[w,w,b,w,b,o,b],[w,w,b,w,o,b,b],[w,w,o,w,b,b,b],[w,w,w,o,b,b,b]]
true ;
[[b,b,b,o,w,w,w],[b,b,o,b,w,w,w],[b,b,w,b,o,w,w],[b,b,w,b,w,o,w],[b,b,w,o,w,b,w],[b,o,w,b,w,b,w],[o,b,w,b,w,b,w],[w,b,o,b,w,b,w],[w,b,w,b,o,b,w],[w,b,w,b,w,b,o],[w,b,w,b,w,o,b],[w,b,w,o,w,b,b],[w,o,w,b,w,b,b],[w,w,o,b,w,b,b],[w,w,w,b,o,b,b],[w,w,w,o,b,b,b]]
true ;
[[b,b,b,o,w,w,w],[b,b,b,w,o,w,w],[b,b,o,w,b,w,w],[o,b,b,w,b,w,w],[b,o,b,w,b,w,w],[b,w,b,o,b,w,w],[b,w,b,w,b,o,w],[b,w,b,w,b,w,o],[b,w,b,w,o,w,b],[b,w,o,w,b,w,b],[o,w,b,w,b,w,b],[w,o,b,w,b,w,b],[w,w,b,o,b,w,b],[w,w,b,w,b,o,b],[w,w,b,w,o,b,b],[w,w,o,w,b,b,b],[w,w,w,o,b,b,b]]
true ;
```

Результат работы поиска в глубину:
```prolog
?- dep().
[[b,b,b,o,w,w,w],[b,o,b,b,w,w,w],[b,b,o,b,w,w,w],[b,b,w,b,o,w,w],[b,b,w,o,b,w,w],[b,b,o,w,b,w,w],[o,b,b,w,b,w,w],[b,o,b,w,b,w,w],[b,w,b,o,b,w,w],[b,w,b,w,b,o,w],[b,w,b,w,b,w,o],[b,w,b,w,o,w,b],[b,w,b,o,w,w,b],[b,o,b,w,w,w,b],[b,b,o,w,w,w,b],[b,b,w,o,w,w,b],[b,b,w,w,o,w,b],[b,b,w,w,w,o,b],[b,b,w,w,w,b,o],[b,b,w,w,o,b,w],[b,b,w,o,w,b,w],[b,b,o,w,w,b,w],[o,b,b,w,w,b,w],[b,o,b,w,w,b,w],[b,w,b,o,w,b,w],[b,w,b,w,o,b,w],[b,w,o,w,b,b,w],[b,o,w,w,b,b,w],[o,b,w,w,b,b,w],[w,b,o,w,b,b,w],[w,b,w,o,b,b,w],[w,b,w,b,o,b,w],[w,b,o,b,w,b,w],[o,b,w,b,w,b,w],[b,o,w,b,w,b,w],[b,w,o,b,w,b,w],[b,w,w,b,o,b,w],[b,w,w,b,w,b,o],[b,w,w,b,w,o,b],[b,w,w,b,o,w,b],[b,w,o,b,w,w,b],[b,o,w,b,w,w,b],[o,b,w,b,w,w,b],[w,b,o,b,w,w,b],[w,b,w,b,o,w,b],[w,b,w,b,w,o,b],[w,b,w,o,w,b,b],[w,b,w,w,o,b,b],[w,b,w,w,b,o,b],[w,b,w,o,b,w,b],[w,b,o,w,b,w,b],[o,b,w,w,b,w,b],[b,o,w,w,b,w,b],[b,w,o,w,b,w,b],[b,w,w,o,b,w,b],[b,w,w,w,b,o,b],[b,w,w,w,o,b,b],[b,w,w,o,w,b,b],[b,o,w,w,w,b,b],[b,w,o,w,w,b,b],[o,w,b,w,w,b,b],[w,o,b,w,w,b,b],[w,w,b,o,w,b,b],[w,w,b,w,o,b,b],[w,w,o,w,b,b,b],[w,w,w,o,b,b,b]]
```

Результат работы поиска в глубину с итерационным углублением:
```prolog
?- idfdep().
[[b,b,b,o,w,w,w],[b,b,b,w,o,w,w],[b,b,o,w,b,w,w],[b,o,b,w,b,w,w],[b,w,b,o,b,w,w],[b,w,b,w,b,o,w],[b,w,b,w,b,w,o],[b,w,b,w,o,w,b],[b,w,o,w,b,w,b],[o,w,b,w,b,w,b],[w,o,b,w,b,w,b],[w,w,b,o,b,w,b],[w,w,b,w,b,o,b],[w,w,b,w,o,b,b],[w,w,o,w,b,b,b],[w,w,w,o,b,b,b]]
```

## Выводы

Благодаря этой лабораторной работе я научился производить поиск в ширину и глубину на языке Пролог. Оказалось, что поиск в глубину не всегда даст желаемый нам результат. Если посмотреть на результат работы поиска, то он нашел решение в 66 шагов за 0.5 секунды. И это не является самым оптимальным решением данной задачи. Самое оптимальное решение нашелся с помощью алгоритма поиска в ширину: всего только 17 шагов, что в 4 раза меньше, чем у поиска в глубину! Но в то же время поиск в ширину занял целых 52 секунды, что в 100 раза больше, чем время поиска в глубину! Также, попытавшись найти другие решения, я с легкостью мог получить другие результаты поиска в глубину. Но, когда я пытался получить остальные результаты поиска в ширину, 4 решение не было найдено из-за нехватки памяти для программы. Так что, можно сделать вывод, что поиск в глубину работает значительно быстрее и выгоднее по памяти, так как очищаются ненужные ветви решения, но может не найти сразу самое оптимальное решение. Поиск в ширину же гарантированно выдает решения по увеличению их длины, но, к сожалению, не эффективен по времени и по памяти.

Оптимальным способом нахождения решения оказался поиск в глубину с итерационным заглублением: за 1 секунду он нашел самые короткие решения, а затем выводил их по мере увеличения длины. Но и у этого поиска есть минусы. Так как он постепенно увеличивает длину пути, то он проходит по одинаковым решениям каждый раз, то это значительно уменьшает скорость работы поиска, и если путь к решению будет очень длинным и решение будет единственным, то может в том случае и не будет самым оптимальным решением.


